\documentclass[12pt]{article}

\usepackage{tikz}
\usepackage[]{algorithm2e}
\usepackage{amsmath}
\usepackage{float}
\begin{document}
\title{Homework 6}
\author{Robbie McKinstry, Jack McQuown, Cyrus Ramavarapu}
\renewcommand{\today}{15 September 2016}
\renewcommand{\baselinestretch}{1.5}
\maketitle

\section*{Problem 5: }
\section*{Problem 6: }
\section*{Problem 7: }

Consider the following input array:

\[
A =
  \begin{bmatrix}
    1 & 2 & -2 & 10
  \end{bmatrix}
\]

Let $MCS$ be the function that calculates the maximum consecutive subarray of $A$, $A[0, n]$ where $n$ is a parameter to the function. Obviously, $MCS(3)$ will return $3$, taking the values 1 and 2 from index 1 and 2 respectively and not taking the value $-2$. Now, a naive implementation of $MCS(n)$ will have a call site with a call to $MCS(n-1)$, but with the above case, knowing that $MCS(3) = 3$ is not enough to know that $MCS(4)$ must be 9. The naive implementation, which has no knowledge that index $n-1$ was not taken, requiring the recombination step to be slightly more sophisticated that simply adding the value at the current index with the value returned from the recursive call site.

To strengthen the inductive hypothesis, we require that $MCS$ not only return the maximum sum of the contiguous subarray elements, but also the index of the final element selected as a member of the contiguous subarray.

Thus, our function signature is now
\[
MCS(n) \to j, max
\]

To implement our algorithm, we first perform a preprocessing step which calculates the sum from an index to the end of the array in linear time. \\

\begin{algorithm}[H]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{An empty, global array B of length $n$}
\BlankLine

\For{$i \leftarrow n $ \KwTo 0}{
	\If{ i == n }{
		$B[n] \leftarrow 0$ \\
		continue
	} 
	$ B[n] \leftarrow B[n-1] + A[n]$
}
\end{algorithm}

This allows the $MCS$ algorithm to look up the sum of the values from a single index to the end of the array in constant time.
Now, we implement $MCS$ as follows... \\

\begin{algorithm}[H]
\SetKwInOut{Input}{input}\SetKwInOut{Output}{output}
\Input{$n$}
\Output{$j, max$}
\BlankLine
	\If{ n == 0 }{
		return 0, 0
	} 
	$k, max = MCS(n-1)$
	
	\If{$Sum(j+1, n) \mathrel{>} 0 $}{
		$return \text{ } n, max \mathrel{+} Sum(j+1, n)$
	}
	\If{$max < A[n]$}{
		$return \text{ } n, n$
	}
	$return \text{ } j, max$
\end{algorithm}

As you can see, this operations acts in linear time, reducing the size of $n$ by 1 until reaching a base case, while only producing a single recursive function call. We still have to define $Sum$, which also acts in linear time. $Sum(i, j)$ is the function that calculates the sum of the values $A[i...j]$ inclusively. To calculate the sum, $Sum$ simply returns the difference between $B[j]$ and $B[i]$, a constant time operation.

Unlike the other problems we did in class, there are no overlapping subproblems that need to be cached for this solution to be efficient. Thus, there is no need to convert the above algorithm to an iterative, array based approach.

\end{document}

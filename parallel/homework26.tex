\documentclass[12pt]{article}

\usepackage{tikz}
\usepackage[ruled, vlined]{algorithm2e}
\usepackage{pst-node,pst-plot}
\usepackage{amsmath}
\usepackage{float}

\newcommand{\BigO}[1]{\ensuremath{\operatorname{\mathcal{O}}\bigl(#1\bigr)}}

\begin{document}
\title{Homework 26}
\author{Robbie McKinstry, Jack McQuown, Cyrus Ramavarapu}
\renewcommand{\today}{2 November 2016}
\renewcommand{\baselinestretch}{1.5}
\maketitle

\section*{Problem 16: }
The problem of merging two sorted arrays in parallel can
be done on an CREW Common PRAM in \BigO{1} time by tabulating
the max values by $n-way$ search.\\\\
Given two sorted arrays, $A$ and $B$, assign one array a $1$ and
the other array $0$.  These values will be used to disambiguate
numbers that are common between the two arrays.  First, for every
value in $A$, concurrently look through the values in $B$ and
generate a $1$ or a $0$ depending on if the value is greater or
less than respectively than the value it is compared against.
For example, if $A$ = {1,3,7,10,18,21} and $B$ = {5,7,21,25,30} and
$A$ was given a $0$ and $B$ was given a $1$, the number $5$ from
$B$ would be given the value 110000.  In the case of the two $7$s,
the $7$ in $A$ is given the value 111000 and the $7$ from $B$ is
given 10000.\\\\
This process is then repeated for the other array.  This results 
in the following two tables:\\
\begin{center}
B = 
\begin{tabular}{c|c|c|c}
num & item & bit value & pos \\\hline
1 & 5 & 110000 & 3 \\\hline
2 & 7 & 111000 & 5 \\\hline
3 & 21 & 111111 & 9 \\\hline
4 & 25 & 111111 & 10 \\\hline
5 & 30 & 111111 & 11 \\\hline
\end{tabular}
A = 
\begin{tabular}{c|c|c|c}
num & item & bit value & pos \\\hline
1 & 1 & 000000 & 1 \\\hline
2 & 3 & 000000 & 2 \\\hline
3 & 7 & 100000 & 4 \\\hline
4 & 10 & 110000 & 6 \\\hline
5 & 18 & 110000 & 7 \\\hline
6 & 21 & 110000 & 8 \\\hline
\end{tabular}
\end{center}
The position column is then generated by looking through the bit
string for each item for each array to find the position where 
there is a 1 followed by a 0.  This position in the bit string 
is then added to the original position to of the item in its 
original array.  This then becomes the position of the item
in the final merged array.\\\\
This process is done in \BigO{1} because the $n-way$ search
is done with $n$ processors and can be concurrently.  Additionally,
the find for the position of a $10$ in each of the tabulated
bit strings can also be done in constant time because each will
be done concurrently using \BigO{n^2} processors, where each processor
is given an individual bit.             
\section*{Problem 20: }

We propose a divide and conquer algorithm for solving this problem.

First, assign to each index a unique processor, and let that index be $k$

Repeat the following for all $i \in Z^{+} < lg(n)$.

We logically separate the arrays $A$ and $B$ into boxes of size $2*2^{i-1}$, where the $j$th box contains the values of $A[2^{j-1}]$ to $A[2^{j}]$ and $B[2^{j-1}]$ to $B[2^{j}]$. Obviously, since this logical distinction does not actually move values, it doesn't have a time complexity since it does not take time to accomplish.

Now, the $k$th processor looks at $B[k]$. If that index is in the same box as that processor, it knows that it can access  $A[B[k]]$ and write that out to $C[k]$. This access is exclusive because in the next step we guarantee that there are a sufficient number of copies of $A[k]$ to ensure that there exists a bijection between any accessing processor and the copies of $A$. If that index is not in the box, that processor does not act, because there might not enough enough copies to guarantee exclusivity. Next, the $k$th processor makes a copy of all cells in $A$ that are also in it's box. This step is bounded above by $n/2$ time, which unfortunately makes the time complexity linear in the worst case, but much closer to logarithmic in cases that are not pathological.

\end{document}

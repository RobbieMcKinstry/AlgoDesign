\documentclass[12pt]{article}

\usepackage{tikz}
\usepackage[ruled, vlined]{algorithm2e}
\usepackage{pst-node,pst-plot}
\usepackage{amsmath}
\usepackage{float}

\newcommand{\BigO}[1]{\ensuremath{\operatorname{\mathcal{O}}\bigl(#1\bigr)}}

\begin{document}
\title{Homework 26}
\author{Robbie McKinstry, Jack McQuown, Cyrus Ramavarapu}
\renewcommand{\today}{2 November 2016}
\renewcommand{\baselinestretch}{1.5}
\maketitle

\section*{Problem 16: }
The problem of merging two sorted arrays in parallel can
be done on an CREW Common PRAM in \BigO{1} time by making
modifications to the serial solution to this problem.\\\\
In serial, a single array would be selected from the two 
sorted arrays, and for each number in this array its appropriate
position would be found in the other array.\\\\
The problem with directly parallelizing the sequential code 
is that there is a data dependence as new values are merged into
the array.  This problem can be overcome by buffering the values
prior to completing the merge.  For example, if it is discovered
that the value to be inserted is smaller than all the values in
the other array, it can be placed into a lower buffer.  Likewise,
values that are greater than all values in the other array would
be placed, temporarily, into a higher buffer.  Since only values
from only one of the arrays will be placed into either of these 
buffers, the order can be maintained based upon the processor rank
which will correspond to the original index in the array.  This
buffering process will also resolve conflicts between values that
end up being mapped to the same location because the buffered values
can be processed based on rank of the processor.\\\\
As an example, consider the following two sorted arrays:\\
\begin{center}
A = 
\begin{tabular}{|c|c|c|c|c|}
\hline
1 & 4  & 5 & 7 & 8\\\hline
\end{tabular}
\\B =  
\begin{tabular}{|c|c|c|c|c|}
\hline
2 & 3  & 6 & 6 & 9\\ \hline
\end{tabular}
\end{center}
Initially, every value in $A$ will look at every value in $B$ to see
which value it is greater than and return either a $0$ or a $1$ 
depending on whether or not it is less than or greater than, respectively.
Since this is a CRCW machine, this can be all done concurrently.\\\\
For each parallel scan, the two end points in $B$ will be monitored.  If
the value being compared is smaller than the first value in $B$ it will be
placed in the lower buffer.  Similarly, if the value is greater than the
largest value in $B$ it will be placed in the higher buffer.  These buffers
will have to be of size $n$ and initialized to some sentinel value because
the values placed into them will be in the same respective index.  In the
above example, the lower buffer ($LB$) will contain \[1,S,S,S,S\] whereas
the higher buffer ($HB$) will be empty.  \\\\
As mentioned above the buffering will also solve conflicts.  In the example,
$7$ and $8$ from array $A$ will both need to be inserterted after $6$.  Since
the values in array $A$ are already sorted, they can be inserted based upon 
their processor id after $6$.\\\\
After every has either been given an insertion position or been placed into
either the $LB$ or the $HB$, these three components can be brought together.
First, an array including $n\times n$ positions is created containing
nothing but sentinel values.  Each value in $B$ is placed at into this new
array in parallel at a location of $n\times (Index\ in\ B)$.  All buffered
values from $A$ are then placed in their appropriate location by using a similar
indexing calculation: $n\times (Index\ into\ B) + Buffer\ Pos$.  Lastly,
the $LB$ and $HB$ are appropriately concantenated at either end.
To filter out any sentinel values, an $2n$ array is created, an a parallel
transfer of any values that are not sentinels are transfered into this array.
Due to this parallel transfer and the time requirement of \BigO{1}, thsi process
requires $n^2$ processors.    
\section*{Problem 20: }

\end{document}

\documentclass[12pt]{article}

\usepackage{tikz}
\usetikzlibrary{trees}
\usepackage[]{algorithm2e}
\usepackage{amsmath}
\newcommand{\BigO}[1]{\ensuremath{\operatorname{O}\bigl(#1\bigr)}}

\begin{document}
\title{Homework 5}
\author{Robbie McKinstry, Jack McQuown, Cyrus Ramavarapu}
\renewcommand{\today}{12 September 2016}
\renewcommand{\baselinestretch}{1.5}

\maketitle

\section*{Greedy Problems}
\subsection*{Problem 7:}
A greedy algorithm that will minimize evictions is to 
select the page that will be accessed furthest in the future
from the current time.\\\\
For example, assuming $k=4$ let the current state of the system be the
following:
\begin{center}
    \begin{tabular}{c|c|c|c|c|c|c|c}
    Time & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
    Input & A & C & D & A & B & A & A \\   
    \end{tabular}
    Fast Memory ($k=4$) 
    \begin{tabular}{c|c|c|c}
    E & D & F & B 
    \end{tabular}
\end{center}
In this situation, the algorithm will evict page B, since
it is not used until time 5.  Any other choice will result
in an earlier eviction. 
\subsubsection*{Proof by Exchange:}
\subsection*{Problem 17:}
A greedy algorithm that will determine if there is enough
information available to fairly partition the goods is as 
follows:\\\\
Given a set of goods $\mathcal{G}={G_1,\ G_2,\dots,G_n}$,
and two orderings on this set, $\mathcal{H}=G_a > G_b >
\cdots > G_n$ and $\mathcal{W}=G_i > G_k > \cdots > G_m$,
partition the goods by initially giving $\mathcal{W}$ and 
$\mathcal{H}$ their maximal elements.
Remove the element given to the opposing list from each list.
If this is not possible
because the maximal elements for both $\mathcal{W}$ and
$\mathcal{H}$ are the same, conclude \textit{that there is not
enough information guarantee a fair partitioning}.\\\\  
While there are elements in $\mathcal{G}$, continue
giving $\mathcal{W}$ and $\mathcal{H}$ their second
most desired element.  Ties are broken arbitrarily.  For 
example, if at a given step both $\mathcal{W}$ and $\mathcal{H}$
want $G_c$, arbitrarily give $G_c$ to $\mathcal{W}$ and
cross it off in the ordering for $\mathcal{H}$ and give
$\mathcal{H}$ the next element in the ordering.\\\\
After all elements have been assigned,first evenly parition  
$\mathcal{H}$ and $\mathcal{W}$ into two equal portions.
If this is not possible because $|\mathcal{G}|$ is odd,
conclude that \textit{there is not enough information available
to fairly partition the goods}.  If the upper half of  
$\mathcal{H}$ and $\mathcal{W}$ is full, conclude that 
\textit{there is enough information to fairly partition}.\\\\
If the upper half of $\mathcal{H}$ or $\mathcal{W}$ are
not full, begin iterating through both orderings and 
check to see that items given alternate with items not given.
If an assignment was reach such that elements from $\mathcal{G}$
can be given to $\mathcal{H}$ and $\mathcal{W}$ such that both
pass at least one test, conclude that \textit{there is enough
information to fairly partition the goods}.  Otherwise, conclude
that \textit{there is not enough information available}.
\subsubsection*{Proof by Exchange:}
This algorithm can be    
\section*{Dynamic Programming}
\subsection*{Problem 2:}
The longest common subsequence between the three can be
initially defined recursively by considering the last 
letter in common between the three strings and then 
seeing if this letter is in the longest common subsequence
of one letter shorter.
\[
S_A = A_1, A_2, A_3,\dots,A_{i-1},A_i
\]
\[
S_B = B_1, B_2, B_3,\dots,B_{j-1},B_j
\]
\[
S_C = C_1, C_2, C_3,\dots,C_{k-1},C_k
\]
Reading right to left, the first letter common to each string will
be the last letter in the longest common subsequence.  As a result,
once this letter is found, problem can be redefined in terms of the 
shorter substrings formed by ignoring the first common point and 
all suceeding letters.\\\\
This analysis leads to the following recursive algorithm:\\\\
\begin{algorithm}[H]
\SetKw{Func}{Function:}
\SetKw{Inp}{Input:}
\Func{LCS\\}
\Inp{$int\ i$, $int\ j$, $int\ k$}\\
\If{$i\equiv j\equiv k\equiv0$}
{$return\ 0$}
\uIf{$A_i\equiv B_j\equiv C_k$}
{$LCS(i-1,j-1,k-1) + A_i$}
\uElseIf{$(A_i\equiv B_j)\neq C_k$}
{$\max(LCS(i-1,\ j-1,\ k),\ LCS(i,\ j,\ k-1))$}
\uElseIf{$(A_i\equiv C_k)\neq B_j$}
{$\max(LCS(i-1,\ j,\ k-1),\ LCS(i, j-1, k))$}
\uElseIf{$A_i\neq (B_j\equiv C_k)$}
{$\max(LCS(i,\ j-1,\ k-1),\ LCS(i-1,\ j,\ k))$}
\Else{$\max(LCS(i,\ j-1,\ k-1),LCS(i-1,\ j,\ k-1),LCS(i-1,\ j-1,\ k))$}
\end{algorithm}
Although this algorithm produces the longest common subsequence for
three given strings, it runs in exponential time due to the numerous
recursive calls that operate on a problem of only $1$ letter smaller.\\\\
By moving to an array based solution and changing the recursive calls 
to array look-ups, a polynomial runtime algorithm can be developed.\\\\
\begin{algorithm}[H]
\SetKw{Func}{Function:}
\SetKw{Inp}{Input:}
\SetKw{Init}{Initialization:}
\SetKw{Calc}{Array Calculations:}
\SetKw{Arr}{Array$[\ ][\ ][\ ]$}
\Func{Array LCS\\}
\Inp{$string\ A$, $String\ B$, $String\ C$}\\ 
\Init\\
\Arr{LCS}\\
\For{$i\leftarrow 0$ to $len(A)$}
{$LCS[i][0][0] = 0$}
\For{$j\leftarrow 0$ to $len(B)$}
{$LCS[0][j][0] = 0$}
\For{$k\leftarrow 0$ to $len(C)$}
{$LCS[0][0][k] = 0$}
\Calc\\
\For{$i\leftarrow 0$ to $len(A)$}
{\For{$j\leftarrow 0$ to $len(B)$}
{\For{$k\leftarrow 0$ to $len(C)$}
{\uIf{$A_i\equiv B_j\equiv C_k$}
{$LCS[i][j][k] = LCS[i-1][j-1][k-1] + 1$}
\uElseIf{$(A_i\equiv B_j)\neq C_k$}
{$LCS[i][j][k]=\max(LCS[i-1][j-1][k],\ LCS[i][j][k-1])$}
\uElseIf{$(A_i\equiv C_k)\neq B_j$}
{$\max(LCS[i][j][k]=LCS[i-1][j][k-1],\ LCS[i][j-1][k])$}
\uElseIf{$A_i\neq (B_j\equiv C_k)$}
{$LCS[i][j][k] = \max(LCS[i][j-1][k-1],\ LCS[i-1][j],[k])$}
\Else{$LCS[i][j][k] = \max(LCS[i][j-1][k-1]$,\\$LCS[i-1][j][k-1],\ LCS[i-1][j-1][k])$}
}
}
}
\end{algorithm}
\end{document}

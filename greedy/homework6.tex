\documentclass[12pt]{article}

\usepackage{tikz}
\usetikzlibrary{trees}
\usepackage[]{algorithm2e}
\usepackage{amsmath}
\newcommand{\BigO}[1]{\ensuremath{\operatorname{O}\bigl(#1\bigr)}}

\begin{document}
\title{Homework 5}
\author{Robbie McKinstry, Jack McQuown, Cyrus Ramavarapu}
\renewcommand{\today}{12 September 2016}
\renewcommand{\baselinestretch}{1.5}

\maketitle

\section*{Greedy Problems}
\subsection*{Problem 7:}
A greedy algorithm that will minimize evictions is to 
select the page that will be accessed furthest in the future
from the current time.\\\\
For example, assuming $k=4$ let the current state of the system be the
following:
\begin{center}
    \begin{tabular}{c|c|c|c|c|c|c|c}
    Time & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
    Input & A & C & D & A & B & A & A \\   
    \end{tabular}
    Fast Memory ($k=4$) 
    \begin{tabular}{c|c|c|c}
    E & D & F & B 
    \end{tabular}
\end{center}
In this situation, the algorithm will evict page B, since
it is not used until time 5.  Any other choice will result
in an earlier eviction. 
\subsubsection*{Proof by Exchange:}
Let $Alg$ be the process by which the above algorithm operates.
Assume there exists an input $I$ such that $Alg(I)$ is 
incorrect.  Let $Opt(I)$ be the optimal result for $I$
that agrees with the greatest number of steps with $Alg(I)$.
$Alg(I)$ and $Opt(I)$ must have a first point of disagreement.
Label this time $t_i$.\\\\
At time $i$, $Alg(I)$ must have evicted some page $u$ and 
$Opt(I)$ has some page $v$ evicted.  Since $Alg(I)$ always
picks the page that will be used furthest in the future,
the next time page $u$ will be used must be further into
the future than the next time page $v$ is used.  Let these
times be respectively $t_u$ and $t_v$.\\\\
Since $Alg(I)$ and $Opt(I)$ both agreed upto time $t_i$,
pages $u$ and $v$ must be in the fast memory of $Opt(I)$
at $t_i$.  Therefore, define $Opt'(I)$ as $Opt(I)$ except
at time $t_i$ evict page $u$ instead of $v$.\\\\
To show that $Opt'(I)$ is at least as optimal as $Opt(I)$     
it needs to be recognized that since $t_u > t_v$, page $v$
will have to be brought back into memory at least $1$ more
time before page $u$ is brought back into memory.\\\\
Since $Opt'(I)$ is at least as optimal as $Opt(I)$ and 
agrees with $Alg(I)$ for $1$ more step a contradiction has
be reached.  Therefore, there is not input for which $Alg$
is incorrect.   
\subsection*{Problem 17:}
A greedy algorithm that will determine if there is enough
information available to fairly partition the goods is as 
follows:\\\\
Given a set of goods $\mathcal{G}={G_1,\ G_2,\dots,G_n}$,
and two orderings on this set, $\mathcal{H}=G_a > G_b >
\cdots > G_n$ and $\mathcal{W}=G_i > G_k > \cdots > G_m$,
partition the goods by initially giving $\mathcal{W}$ and 
$\mathcal{H}$ their maximal elements.
Remove the element given to the opposing list from each list.
If this is not possible
because the maximal elements for both $\mathcal{W}$ and
$\mathcal{H}$ are the same, conclude \textit{that there is not
enough information guarantee a fair partitioning}.\\\\  
While there are elements in $\mathcal{G}$, continue
giving $\mathcal{W}$ and $\mathcal{H}$ their second
most desired element.  Ties are broken arbitrarily.  For 
example, if at a given step both $\mathcal{W}$ and $\mathcal{H}$
want $G_c$, arbitrarily give $G_c$ to $\mathcal{W}$ and
cross it off in the ordering for $\mathcal{H}$ and give
$\mathcal{H}$ the next element in the ordering.\\\\
After all elements have been assigned,first evenly parition  
$\mathcal{H}$ and $\mathcal{W}$ into two equal portions.
If this is not possible because $|\mathcal{G}|$ is odd,
conclude that \textit{there is not enough information available
to fairly partition the goods}.  If the upper half of  
$\mathcal{H}$ and $\mathcal{W}$ is full, conclude that 
\textit{there is enough information to fairly partition}.\\\\
If the upper half of $\mathcal{H}$ or $\mathcal{W}$ are
not full, begin iterating through both orderings and 
check to see that items given alternate with items not given.
If an assignment was reach such that elements from $\mathcal{G}$
can be given to $\mathcal{H}$ and $\mathcal{W}$ such that both
pass at least one test, conclude that \textit{there is enough
information to fairly partition the goods}.  Otherwise, conclude
that \textit{there is not enough information available}.
\subsubsection*{Proof by Exchange:}
This algorithm can be shown to be correct by an exchange argument.
Let $Alg$ be the process by which the above algorithm operates.
Assume there exists some input $I$ such that $Alg(I)$ is incorrect.
Let $Opt(I)$ be the optimal output for input $I$ that aggrees with
$Alg(I)$ for the most number of steps.  Therefore, $Alg(I)$ and $Opt(I)$
must have a first point of disagreement.  Label this step $s_i$.\\\\
At $s_i$, $Alg(I)$ must have given a different pair of goods to
$\mathcal{H}$ and $\mathcal{W}$ than $Opt(I)$.  This could mean that
$Alg(I)$ respectiely gave $\mathcal{H}$ and $\mathcal{W}$ $G_a,\ G_b$      
whereas $Opt(I)$ gave $G_c,\ G_d$.
%Have to consider the case where they have alternating patterns or 
%balanced partitions.
\section*{Dynamic Programming}
\subsection*{Problem 2:}
The longest common subsequence between the three can be
initially defined recursively by considering the last 
letter in common between the three strings and then 
seeing if this letter is in the longest common subsequence
of one letter shorter.
\[
S_A = A_1, A_2, A_3,\dots,A_{i-1},A_i
\]
\[
S_B = B_1, B_2, B_3,\dots,B_{j-1},B_j
\]
\[
S_C = C_1, C_2, C_3,\dots,C_{k-1},C_k
\]
Reading right to left, the first letter common to each string will
be the last letter in the longest common subsequence.  As a result,
once this letter is found, problem can be redefined in terms of the 
shorter substrings formed by ignoring the first common point and 
all suceeding letters.\\\\
This analysis leads to the following recursive algorithm:\\\\
\begin{algorithm}[H]
\SetKw{Func}{Function:}
\SetKw{Inp}{Input:}
\Func{LCS\\}
\Inp{$int\ i$, $int\ j$, $int\ k$}\\
\If{$i\equiv j\equiv k\equiv0$}
{$return\ 0$}
\uIf{$A_i\equiv B_j\equiv C_k$}
{$LCS(i-1,j-1,k-1) + A_i$}
\uElseIf{$(A_i\equiv B_j)\neq C_k$}
{$\max(LCS(i-1,\ j-1,\ k),\ LCS(i,\ j,\ k-1))$}
\uElseIf{$(A_i\equiv C_k)\neq B_j$}
{$\max(LCS(i-1,\ j,\ k-1),\ LCS(i, j-1, k))$}
\uElseIf{$A_i\neq (B_j\equiv C_k)$}
{$\max(LCS(i,\ j-1,\ k-1),\ LCS(i-1,\ j,\ k))$}
\Else{$\max(LCS(i,\ j-1,\ k-1),LCS(i-1,\ j,\ k-1),LCS(i-1,\ j-1,\ k))$}
\end{algorithm}
Although this algorithm produces the longest common subsequence for
three given strings, it runs in exponential time due to the numerous
recursive calls that operate on a problem of only $1$ letter smaller.\\\\
By moving to an array based solution and changing the recursive calls 
to array look-ups, a polynomial runtime algorithm can be developed.\\\\
\begin{algorithm}[H]
\SetKw{Func}{Function:}
\SetKw{Inp}{Input:}
\SetKw{Init}{Initialization:}
\SetKw{Calc}{Array Calculations:}
\SetKw{Arr}{Array$[\ ][\ ][\ ]$}
\Func{Array LCS\\}
\Inp{$string\ A$, $String\ B$, $String\ C$}\\ 
\Init\\
\Arr{LCS}\\
\For{$i\leftarrow 0$ to $len(A)$}
{$LCS[i][0][0] = 0$}
\For{$j\leftarrow 0$ to $len(B)$}
{$LCS[0][j][0] = 0$}
\For{$k\leftarrow 0$ to $len(C)$}
{$LCS[0][0][k] = 0$}
\Calc\\
\For{$i\leftarrow 0$ to $len(A)$}
{\For{$j\leftarrow 0$ to $len(B)$}
{\For{$k\leftarrow 0$ to $len(C)$}
{\uIf{$A_i\equiv B_j\equiv C_k$}
{$LCS[i][j][k] = LCS[i-1][j-1][k-1] + 1$}
\uElseIf{$(A_i\equiv B_j)\neq C_k$}
{$LCS[i][j][k]=\max(LCS[i-1][j-1][k],\ LCS[i][j][k-1])$}
\uElseIf{$(A_i\equiv C_k)\neq B_j$}
{$\max(LCS[i][j][k]=LCS[i-1][j][k-1],\ LCS[i][j-1][k])$}
\uElseIf{$A_i\neq (B_j\equiv C_k)$}
{$LCS[i][j][k] = \max(LCS[i][j-1][k-1],\ LCS[i-1][j],[k])$}
\Else{$LCS[i][j][k] = \max(LCS[i][j-1][k-1]$,\\$LCS[i-1][j][k-1],\ LCS[i-1][j-1][k])$}
}
}
}
\end{algorithm}
\end{document}
